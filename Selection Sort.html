<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        svg
        {
            border-style: solid;
        }

        g > circle
        {
            stroke: black;
            cursor: move;
            cursor: grab;
            cursor: -moz-grab;
            cursor: -webkit-grab;
        }

        g > circle:active
        {
            cursor: grabbing;
            cursor: -moz-grabbing;
            cursor: -webkit-grabbing;
        }

        g > circle + text
        {
            font-family: sans-serif;
            cursor: move;
            cursor: grab;
            cursor: -moz-grab;
            cursor: -webkit-grab;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        g > text:active
        {
            cursor: grabbing;
            cursor: -moz-grabbing;
            cursor: -webkit-grabbing;
        }

        g > rect
        {
            fill: white;
            stroke: black;
            stroke-width: 10px;
        }

        .actionButton
        {
            cursor: pointer;
        }

        .actionButton + text
        {
            font-family: sans-serif;
            cursor: pointer;
        }

        .dragging
        {
            stroke-width: 7px;
        }

    </style>
    <script src = "https://cdnjs.cloudflare.com/ajax/libs/d3/4.9.1/d3.min.js" ></script>
    <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
    <script>
        const w = 1000;
        const h = 800;
        const arrPadding = 50;
        const arrHeight = 150;
        const arrEncapWidth = 50;
        const arrSpacing = w - arrEncapWidth * 2 - arrPadding * 2;
        const arrLeft = arrPadding;
        const arrRight = arrPadding + arrEncapWidth * 2 + (arrSpacing);
        const arrTop = arrPadding;
        const arrBottom = arrPadding + arrHeight;
        const arrYMiddle = arrPadding + arrHeight / 2;
        const arrTopLeftPos = [arrPadding, arrPadding];
        const arrTopRightPos = [arrRight, arrPadding];
        const arrBottomLeftPos = [arrPadding, arrPadding + arrHeight];
        const arrBottomRightPos = [arrRight, arrPadding + arrHeight];
        const arrNodePadding = 10;
        const buttonWidth = 300;
        const buttonHeight = 100;

        var r = 50;
        var graphicArray = [];
        var graphicArrayGTag = [];
        var graphicArrayLoc = [];
        var data = [];
        var fontSize = 64;
        var button = null;

        class Node
        {
            constructor(x, y, r, value)
            {
                this.x = x;
                this.y = y;
                this.r = r;
                this.value = value;
            }
        }

        function selectionSort()
        {
            var startIndex = 0;
            selectionSortOnce();

            function selectionSortOnce()
            {
                if (startIndex === graphicArray.length - 1)
                {
                    return;
                }
                else {
                    var minG = graphicArray[startIndex];
                    var minGIndex = startIndex;
                    var currentMin = minG.datum().value;
                    var minNode = prevNode = minG.selectAll("circle");
                    var minNodeColor = minNode.attr("fill");
                    var interval = setInterval(visitNextNode, 1000);
                    var prevColor = prevNode.attr("fill");
                    prevNode.attr("fill", "red");
                    var i = startIndex + 1;
                    ;
                    function visitNextNode() {
                        if (i === graphicArray.length) {
                            graphicArray[i - 1].selectAll("circle").attr("fill", prevColor);
                            clearInterval(interval);
                            var temp = graphicArray[startIndex];
                            graphicArray[startIndex] = minG;
                            graphicArray[minGIndex] = temp;
                            graphicArrayGTag[startIndex] = minG.node();
                            graphicArrayGTag[minGIndex] = temp.node();
                            minG.selectAll("circle").attr("fill", minNodeColor);
                            updateArrayNodes();
                            startIndex += 1;
                            selectionSortOnce();
                        }
                        else {
                            prevNode.attr("fill", prevColor);

                            var g = graphicArray[i];

                            if (g.datum().value < currentMin) {
                                minNode.attr("fill", minNodeColor);
                                currentMin = g.datum().value;
                                minNode = g.selectAll("circle");
                                minNodeColor = minNode.attr("fill");
                                minG = g;
                                minGIndex = i;
                            }
                            var node = g.selectAll("circle");
                            var tempColor = node.attr("fill");
                            node.attr("fill", "red");
                            minNode.attr("fill", "yellow");

                            prevNode = node;
                            prevColor = tempColor;
                            i++;
                        }
                    }
                }
            }
        }


        function iterateGraphicArray()
        {
            var interval = setInterval(visitNextNode, 1000);
            var prevNode = graphicArray[0].selectAll("circle");
            var prevColor = prevNode.attr("fill");
            prevNode.attr("fill", "red");
            var i = 1;
            function visitNextNode()
            {
                if (i === graphicArray.length)
                {
                    graphicArray[i - 1].selectAll("circle").attr("fill", prevColor);
                    clearInterval(interval);
                }
                else
                {
                    prevNode.attr("fill", prevColor);
                    var node = graphicArray[i].selectAll("circle");
                    var tempColor = node.attr("fill");
                    node.attr("fill", "red");

                    prevNode = node;
                    prevColor = tempColor;
                    i++;
                }
            }
        }

        function inGraphicArray(g)
        {
            var radius = g.datum().r;
            if (d3.event.x + radius > arrLeft && d3.event.x - radius < arrRight && d3.event.y - radius < arrBottom && d3.event.y + radius > arrTop )
            {
                return true;
            }
        }

        function updateArrayNodes()
        {
            var startingPos = (w / 2) - ((graphicArray.length - 1) * (r + arrNodePadding));
            for (var i = 0; i < graphicArray.length; i++) {
                var x = startingPos + 2 * i * (r + arrNodePadding);
                var y = arrYMiddle;
                graphicArrayLoc[i] = [x, y];
                var g = graphicArray[i].transition()
                    .duration(300)
                    .attr("transform", "translate(" + (graphicArray[i].datum().x = x) + "," + (graphicArray[i].datum().y = y) + ")");
            }
        }

        function updateArrayNodeRadius()
        {
            for (var i = 0; i < graphicArray.length; i++)
            {
                graphicArray[i].datum().r = r;
                graphicArray[i].selectAll("circle")
                    .attr("r", r);
            }
        }

        function pushToGraphicArray(g)
        {
            if (graphicArrayGTag.indexOf(g.node()) === -1)
            {
                graphicArray.push(g);
                graphicArrayGTag.push(g.node())
            }
            updateArrayNodes();
        }

        function addButton(f)
        {
            var svg = d3.selectAll("svg");
            var g = svg.append("g")
                .attr("transform", "translate(" + (w / 2 - buttonWidth / 2) + "," + (h * 0.75) + ")")
                .on("click", selectionSort);
            button = g;

            var rect = g.append("rect")
                .attr("width", buttonWidth)
                .attr("height", buttonHeight)
                .classed("actionButton", true);

            var text = g.append("text")
                .text("Selection Sort")
                .attr("transform", "translate(" + (buttonWidth / 2) + "," + (buttonHeight / 2) + ")")
                .attr("text-anchor", "middle")
                .attr("y", ".3em")
                .attr("font-size", (buttonWidth / 10) + "pt");

        }

        function dragStarted()
        {
            var g = d3.select(this).classed("dragging", true).raise();

            d3.event.on("drag", dragged)
                .on("end", dragEnded);

            function dragged()
            {
                g.attr("transform", function(d) {
                    var coordinates = d3.mouse(d3.select("svg").node());
                    return "translate(" + (d.x = coordinates[0]) + "," + (d.y = coordinates[1]) + ")";
                });
                if (inGraphicArray(g))
                {
                    d3.select(".array")
                        .style("fill", "rgb(240, 240, 240)")
                }
                else if (d3.select(".array").style("fill") == "rgb(240, 240, 240)")
                {
                    d3.select(".array")
                        .style("fill", "none")
                }
            }

            function dragEnded()
            {
                g.classed("dragging", false);
                if (inGraphicArray(g))
                {
                    d3.select(".array")
                        .style("fill", "none");
                    if ((graphicArray.length + 1) * (r * 2 + arrNodePadding * 2) > w - arrEncapWidth * 2)
                    {
                        //overflow
                    }
                    else
                    {
                        pushToGraphicArray(g);
                        if (graphicArray.length >= 1)
                        {
                            addButton(selectionSort);
                        }
                    }
                }
                else
                {
                    var removeFromArray = null;
                    if ((removeFromArray = graphicArrayGTag.indexOf(g.node())) !== -1)
                    {
                        graphicArray.splice(removeFromArray, 1);
                        graphicArrayGTag.splice(removeFromArray, 1);
                        updateArrayNodes();
                    }
                    if (graphicArray.length === 0 && button)
                    {
                        button.remove();
                    }
                }
            }
        }

        function addNodeToSvg()
        {
            data.push(new Node(d3.event.x, d3.event.y, r, Math.floor(Math.random() * 255)));
            var nodes = d3.select("svg")
                .selectAll(".nodes")
                .data(data)
                .enter();
            updateNodes(nodes);
        }

        function updateNodes(nodes)
        {
            var g = nodes.append("g")
                .classed("nodes", true)
                .call(d3.drag().on("start", dragStarted))
                .attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")"
                });

            var node = g.append("circle")
                .attr("r", function(d) { return d.r } )
                .attr("fill", function(d) { return "rgb(" + (255 - d.value) + ", 255, 255)" } );

            var text = g.append("text")
                .text(function(d) { return d.value })
                .attr("text-anchor", "middle")
                .attr("y", ".3em")
                .attr("font-size", function(d) {
                    return fontSize - String(d.value).length * 6;
                });
        }

        function updateArray(svg, data)
        {
            var g = svg.append("g")
                .data(data)
                .attr("transform", function(d) {
                    return "translate(" + arrPadding + "," + arrPadding + ")";
                })

            var array = g.append("rect")
                .attr("width", w - arrPadding * 2)
                .attr("height", arrHeight)
                .classed("array", true)
                .style("stroke-dasharray", String(arrEncapWidth) + "," + String(arrSpacing) + "," + String(arrEncapWidth * 2 + arrHeight) + "," + String(arrSpacing) + "," + String(arrEncapWidth * 2 + arrHeight) );

        }

        function initialize()
        {
            var svg = d3.select("body")
                .append("svg")
                .attr("width", w)
                .attr("height", h)
                .on("click", function () {
                    if (d3.event.target === this) {
                        addNodeToSvg()
                    }
                });

            var nodes = svg.selectAll(".nodes");

            updateArray(svg, [0]);
        }

        $(document).ready(function() {
           initialize();
        });
    </script>
    <title>d3.js</title>
</head>
<body>

</body>
</html>